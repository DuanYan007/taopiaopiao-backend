# 仿大麦系统

## 1. 架构设计目标

本项目为一个仿照大麦票务系统的后端练手项目，围绕票务系统中常见的业务形态与系统压力场景进行架构设计。该架构书用于明确系统的业务边界、系统拆分方式及关键能力分布，为后续实现提供清晰的整体设计依据。

### 1.1 业务目标

系统包含两类业务场景，并在同一产品形态下统一建模与拆分：

1. **正常演出业务（非高并发场景）**  
   - 支持演出、场馆、场次等核心业务对象的管理与维护  
   - 覆盖管理端（演出 / 场馆 / 场次的增删查改）与客户端（演出信息浏览、查询）  
   - 以稳定读写、数据一致性和业务扩展为主要关注点  

2. **高并发抢票 / 秒杀业务**  
   - 面向热门演出场次的集中抢票场景  
   - 涉及预约校验、资格过滤、抢购、锁座、下单、超时释放等流程  
   - 以并发控制、资源保护和系统稳定性为主要关注点  

通过在同一系统中同时支持上述两类业务，体现不同业务场景在架构层面的差异化处理方式。

### 1.2 物理与环境约束目标

系统部署与运行基于以下客观条件：

- 开发与运行环境为单台 Windows 10 设备  
- 可用物理内存约 16GB  
- 通过多端口、多进程方式部署多个服务实例  
- 以逻辑方式模拟服务注册、路由转发及服务间通信  

在该环境下完成微服务拆分与组件部署，要求架构在单机条件下可完整运行，同时在设计层面具备向多节点环境扩展的空间。

### 1.3 场景覆盖目标

系统在架构层面覆盖票务系统中常见的工程场景，包括：

- 正常业务与秒杀业务的拆分与隔离  
- 多级缓存用于演出与场次信息查询  
- 多级流量控制与请求削峰  
- 核心资源（座位、订单）的状态流转建模  
- 基于消息机制的异步处理与解耦  
- 异常场景下的状态回收与系统恢复路径设计  

上述场景作为架构设计的重要组成部分，用于支撑后续系统模块划分与关键链路设计。

## 2. 系统整体分层架构

在系统层面，引入**双业务域架构**，以隔离不同性质业务的复杂度与风险。系统被明确划分为：

- **演出业务域（Normal Business Domain）**：承载演出、场馆、场次等常规业务，特点为低并发、读多写少。
- **抢票业务域（Seckill Domain）**：承载高并发选座与下单逻辑，特点为高碰撞、强一致性。

双业务域在逻辑上解耦，在流量模型、缓存策略与一致性策略上完全隔离。

------

## 2.1 接入层（Edge Layer · OpenResty）

系统整体采用自上而下的分层架构设计，各层之间通过清晰接口解耦。

### 2.1 接入层（Edge Layer · OpenResty）

**层级定位**：

- 系统的第一道闸门
- 位于所有 Java 微服务之前

**核心职责**：

- 抢票资格校验（预约用户校验）
- Bloom Filter 初筛非法用户
- 抢票资格 Token 校验
- JWT 合法性快速校验
- 用户行为限流（IP / UID 粒度）
- 售完标志快速拦截

**设计目标**：

- 将逻辑高并发请求削减至系统可承受范围
- 避免无效流量进入后端微服务体系

------

### 2.2 网关层（Gateway Layer · Spring Cloud Alibaba Gateway）

**层级定位**：

- JVM 世界的统一入口

**核心职责**：

- 动态路由分发
- 统一鉴权与请求规范化
- 灰度与流量治理策略承载

**设计说明**：

- 网关不承载具体业务逻辑
- 仅做协议与路由层面的统一处理

------

### 2.3 业务服务层（Business Service Layer）

业务服务层按业务域进行逻辑拆分，以体现微服务架构在复杂度隔离上的核心价值。

#### 2.3.1 演出业务服务组（Normal Business Domain）

**服务职责定位**：

- 承载非秒杀场景下的演出相关业务

**逻辑服务划分**：

- Show Service（演出信息）
- Venue Service（场馆信息）
- Session Service（场次信息）
- Seat Template Service（座位模板）

**业务特征**：

- 低并发
- 读多写少
- 不参与抢票核心链路

------

#### 2.3.2 抢票业务服务组（Seckill Domain）（Business Service Layer）

业务服务层由多个职责单一、可独立扩展的微服务组成。

#### 2.3.2.1 Seckill Service（核心选座服务）

**职责定位**：

- 抢票系统的核心业务引擎

**核心职责**：

- 接收合法抢票请求
- 调用 Redis Lua 脚本完成原子选座锁定
- 发送选座结果事件消息

**架构特征**：

- 无状态设计
- 高并发、短执行路径
- 不直接依赖数据库

------

#### 2.3.2 Order Service（订单服务）

**职责定位**：

- 负责订单生命周期管理

**核心职责**：

- 基于事务消息创建订单记录
- 管理订单状态流转（锁定 / 已支付 / 已取消）
- 触发超时取消与资源释放

**架构特征**：

- 强一致性关注点
- 与消息系统深度绑定

------

#### 2.3.3 Notification Service（通知服务）

**职责定位**：

- 系统状态变化的对外感知通道

**核心职责**：

- 消费选座与订单变更事件
- 通过 SSE 向前端推送增量状态

**架构特征**：

- 完全异步
- 非关键路径
- 可随时降级或停用

------

### 2.4 数据与中间件层（Data & Middleware Layer）

#### 2.4.1 多级缓存体系（演出查询场景）

为优化演出业务域下的大量查询请求，引入分层缓存架构：

- **L1：客户端缓存**
  - 浏览器本地缓存 / HTTP Cache
  - 承担最外层读请求削减
- **L2：边缘缓存（OpenResty）**
  - 演出基础信息
  - 场馆结构数据
  - 静态座位模板
- **L3：服务端缓存（Redis）**
  - 演出详情
  - 场次配置
  - 价格与规则信息

该缓存体系**不包含实时座位状态**，并与抢票业务 Redis 数据完全隔离。

------

#### 2.4.2 Redis（抢票业务）

（Data & Middleware Layer）

#### 2.4.1 Redis

- 存储座位实时状态
- 执行 Lua 原子选座逻辑
- 承载抢票核心并发压力

#### 2.4.2 RocketMQ

- 承载跨服务异步通信
- 提供事务消息保证最终一致性
- 提供延迟消息支持超时取消

#### 2.4.3 MySQL

- 存储订单与基础业务数据
- 不直接参与抢票核心链路

------

### 2.5 外部与预留系统

#### 2.5.1 用户系统（User Service · 逻辑外部）

- 提供用户身份、登录、实名能力
- 核心链路仅依赖 uid，不强耦合用户系统

------

## 3. 核心业务模块说明

### 3.1 预约与抢票资格模块

- 抢票前用户需完成预约
- 预约成功用户进入资格池
- 抢票阶段通过 OpenResty 快速校验

------

### 3.2 选座引擎模块

- 客户端一次性提交 seat_id 列表
- Redis Lua 脚本完成原子校验与锁定
- 高碰撞下保证座位一致性

------

### 3.3 订单模块

- 锁座成功后异步创建订单
- 支持支付与超时取消
- 取消后触发座位释放

------

### 3.4 实时通知模块

- 通过 MQ 解耦状态变更
- SSE 推送最小化数据
- 前端按需局部刷新

------

## 4. 核心业务链路说明

### 4.1 抢票核心链路

预约校验 → OpenResty 削峰 → Gateway → Seckill Service → Redis 原子锁座 → MQ 事件

------

### 4.2 非核心链路

- 订单创建
- 状态推送
- 超时取消

全部通过异步方式完成，不影响抢票主流程。

------

## 5. 非功能性架构设计

### 5.1 高并发与削峰设计

- 边缘层承担主要削峰职责
- 核心链路 QPS 控制在可控范围内

### 5.2 扩展性设计

- 所有服务无状态
- Redis / MQ / DB 可独立扩容

### 5.3 单机受限环境运行策略

- 中间件与 JVM 服务严格限制内存
- 保证多服务并存下的系统稳定性

------

## 6. 核心状态机与一致性设计

核心状态机用于明确系统中**关键资源状态的演进规则**，避免并发场景下的状态混乱，并为异常处理、兜底恢复提供确定性依据。本系统中存在两类核心状态机：**座位状态机**与**订单状态机**。

------

### 6.1 座位状态机（Seat State Machine）

> 座位状态机仅适用于**抢票业务域**。演出业务域下的演出、场馆、场次等 CRUD 操作，不纳入核心状态机模型，仅遵循普通数据一致性约束。

#### 6.1.1 状态定义（Seat State Machine）

#### 6.1.1 状态定义

| 状态      | 标识值 | 含义说明                       |
| --------- | ------ | ------------------------------ |
| AVAILABLE | 0      | 座位可被选座                   |
| LOCKED    | 1      | 座位已被某用户锁定，未完成支付 |
| SOLD      | 2      | 座位已完成支付并最终售出       |

------

#### 6.1.2 状态流转规则

AVAILABLE → LOCKED → SOLD

AVAILABLE → LOCKED → AVAILABLE（超时取消 / 主动取消）

------

#### 6.1.3 状态流转约束

- **AVAILABLE → LOCKED**
  - 仅允许通过 Redis Lua 原子脚本完成
  - 必须校验用户未购、座位未被占用
- **LOCKED → SOLD**
  - 仅在订单支付成功后触发
  - 由订单系统通过异步消息通知完成
- **LOCKED → AVAILABLE**
  - 仅在订单取消或支付超时后触发
  - 通过延迟消息或取消事件驱动

所有座位状态流转均以 Redis 为最终裁决源，避免跨服务直接修改状态。

------

### 6.2 订单状态机（Order State Machine）

#### 6.2.1 状态定义

| 状态              | 含义说明                 |
| ----------------- | ------------------------ |
| INIT              | 订单初始化（尚未锁座）   |
| LOCKED            | 已完成座位锁定，等待支付 |
| PAYING            | 支付处理中               |
| PAID              | 支付完成，订单成功       |
| CANCELLED         | 用户主动取消             |
| TIMEOUT_CANCELLED | 超时未支付自动取消       |

------

#### 6.2.2 状态流转规则

INIT → LOCKED → PAYING → PAID

LOCKED → CANCELLED

LOCKED → TIMEOUT_CANCELLED

------

#### 6.2.3 状态流转驱动方式

- INIT → LOCKED
  - 由 Seckill Service 成功锁座后，通过事务消息触发
- LOCKED → PAYING / PAID
  - 由支付系统事件驱动（逻辑外部）
- LOCKED → CANCELLED
  - 用户主动取消订单
- LOCKED → TIMEOUT_CANCELLED
  - 延迟消息到期触发

订单状态流转仅允许**前向推进**，不允许跨状态跳转，确保状态演进可追溯。

------

### 6.3 状态机与最终一致性关系

#### 6.3.1 一致性设计原则

- Redis 座位状态是**高并发下的强一致性控制点**
- MySQL 订单状态是**业务最终结果的持久化记录**
- RocketMQ 作为状态流转的事件驱动纽带

------

#### 6.3.2 典型一致性链路

1. 座位由 AVAILABLE → LOCKED（Redis 原子成功）
2. 发送事务消息，创建订单（Order: LOCKED）
3. 支付成功 → Order: PAID
4. 异步通知座位状态 LOCKED → SOLD

------

### 6.4 状态机设计收益

- 明确系统中“谁能改状态、何时能改状态”
- 为高并发与异常场景提供确定性处理路径
- 为后续扩展（补偿、审计、监控）提供统一模型

------

## 7. 失败场景与兜底架构设计（Failure & Fallback）

在高并发分布式系统中，**失败不是异常，而是常态**。本系统通过明确失败场景分类、限定失败影响范围，并结合状态机与消息机制，构建可恢复、可回滚、可追溯的兜底架构。

------

### 7.1 失败设计基本原则

- **失败可预期**：所有关键链路必须假设下游可能失败
- **失败可隔离**：单点失败不得扩散至其他业务域
- **失败可回收**：资源必须具备确定性的释放路径
- **失败可重放**：通过消息驱动实现状态补偿

------

### 7.2 核心失败场景分类

#### 7.2.1 Lua 锁座成功，但消息发送失败

**场景描述**：

- Redis Lua 已成功将座位状态置为 LOCKED
- RocketMQ 事务消息未成功提交

**风险**：

- 座位被长期占用，无法下单

**兜底策略**：

- 座位 LOCKED 状态必须绑定 TTL 或可回滚标记
- 后台定期扫描 LOCKED 座位
- 对无订单关联的 LOCKED 座位触发释放事件

------

#### 7.2.2 事务消息已提交，但本地事务失败

**场景描述**：

- 事务消息提交成功
- Order Service 本地事务回滚

**兜底策略**：

- RocketMQ 回查机制触发
- 依据订单表状态判定事务结果
- 未落库订单触发座位释放

------

#### 7.2.3 消息重复投递或重复消费

**场景描述**：

- MQ 至少一次投递语义

**兜底策略**：

- 所有消费逻辑具备幂等性
- 基于订单号 / 座位锁定标识进行去重
- 重复消息不引起状态二次变更

------

#### 7.2.4 延迟消息丢失或未按时触发

**场景描述**：

- 超时取消消息未触发

**兜底策略**：

- 延迟消息作为“主动回收”手段
- 后台补偿任务作为“最终兜底”
- 双通道保证 LOCKED 状态必然被回收

------

#### 7.2.5 Notification Service 不可用

**场景描述**：

- SSE 推送服务宕机或不可用

**兜底策略**：

- 不影响抢票与下单主流程
- 前端通过主动刷新恢复最新状态
- 消息堆积后可继续消费

------

### 7.3 失败影响范围隔离

- 演出业务域失败不影响抢票业务域
- 通知失败不影响核心交易链路
- 查询缓存失效不影响秒杀 Redis

------

### 7.4 失败恢复与系统自愈能力

- 所有核心状态变更均可由事件驱动重放
- 状态机确保非法状态不可达
- 后台补偿机制作为最终安全网



| 组件          | 对应业务 / 使用场景                                          |
| ------------- | ------------------------------------------------------------ |
| OpenResty     | 秒杀接口前置限流、流量削峰（仅秒杀业务）                     |
| Gateway       | 请求统一入口、业务路由分发（普通业务 / 秒杀业务 / 管理端）、身份解析透传 |
| Nacos         | 服务注册与发现、配置管理（全业务域）                         |
| Sentinel      | 接口级限流、熔断降级（秒杀业务为主，普通业务保护）           |
| Seata         | 分布式事务控制（订单创建与相关服务间一致性保障）             |
| 本地缓存      | 热门演出与场次查询缓存（普通查询业务）                       |
| Redis（缓存） | 演出 / 场次数据缓存（普通查询业务）                          |
| Redis（裁决） | 座位库存、锁座状态、预约用户集合、Lua 原子扣减（秒杀业务）   |
| Bloom Filter  | 预约资格初筛（秒杀业务）                                     |
| MySQL         | 演出 / 场馆 / 场次数据持久化、订单数据存储                   |
| RocketMQ      | 抢票成功后异步下单、削峰处理、延迟取消、事务一致性（秒杀业务） |